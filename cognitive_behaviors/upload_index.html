<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>LLM Reasoning Trace Annotator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
      /* small helper so highlighted spans have a visible inline padding */
      .annotation-span { padding: 0 0.05rem; border-radius: 0.15rem; }
      /* ensure highlighted spans are inline and wrap properly */
      .annotation-span { display: inline; }
    </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
const { useState, useEffect, useRef } = React;

/* ----- Icons ----- */
const ChevronLeft = ({ size = 24 }) => (
  <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
    <polyline points="15 18 9 12 15 6"></polyline>
  </svg>
);
const ChevronRight = ({ size = 24 }) => (
  <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
    <polyline points="9 18 15 12 9 6"></polyline>
  </svg>
);
const Download = ({ size = 20 }) => (
  <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
    <polyline points="7 10 12 15 17 10"></polyline>
    <line x1="12" y1="15" x2="12" y2="3"></line>
  </svg>
);
const Trash2 = ({ size = 18 }) => (
  <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
    <polyline points="3 6 5 6 21 6"></polyline>
    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
    <line x1="10" y1="11" x2="10" y2="17"></line>
    <line x1="14" y1="11" x2="14" y2="17"></line>
  </svg>
);
const Upload = ({ size = 20 }) => (
  <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
    <polyline points="17 8 12 3 7 8"></polyline>
    <line x1="12" y1="3" x2="12" y2="15"></line>
  </svg>
);

/* ----- Sample data & behaviors ----- */
const SAMPLE_DATA = [
  {
    id: "trace_001",
    question: "What is the capital of France?",
    reasoning: "Let me think about this question. France is a country in Europe. The capital city is where the government is located. Paris is the largest city in France and serves as its capital. Therefore, the answer is Paris."
  },
  {
    id: "trace_002",
    question: "If a train travels 120 miles in 2 hours, what is its average speed?",
    reasoning: "To find average speed, I need to divide distance by time. The train traveled 120 miles in 2 hours. So the calculation is 120 รท 2 = 60. The average speed is 60 miles per hour."
  },
  {
    id: "trace_003",
    question: "What are the primary colors?",
    reasoning: "Primary colors are the base colors that cannot be created by mixing other colors. In traditional color theory, the primary colors are red, yellow, and blue. These three colors can be mixed to create all other colors on the color wheel."
  }
];

const COGNITIVE_BEHAVIORS = [
  'self-awareness','strategy-selection','goal-management','self-evaluation',
  'logical-coherence','compositionality','productivity','conceptual-level-processing',
  'hierarchical-organization','graph-organization','sequential-organization',
  'ordinal-organization','causal-organization','spatial-organization','temporal-organization',
  'context-dependent-structure-adoption','knowledge-structure-alignment','verification',
  'selective-attention','adaptive-detail-management','decomposition-and-integration',
  'representational-restructuring','pattern-recognition','abstraction','forward-chaining',
  'backward-chaining','backtracking'
];

// Behavior -> tailwind class map (easy to edit)
const BEHAVIOR_COLOR = {
  'self-awareness': 'bg-orange-300',
  'strategy-selection': 'bg-blue-300',
  'goal-management': 'bg-green-300',
  'self-evaluation': 'bg-purple-300',
  'default': 'bg-orange-300'
};

/* ----- Component ----- */
function LLMTraceAnnotator() {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [annotations, setAnnotations] = useState({}); // { traceId: { spans: [ {id, text, behavior, score, start, end} ] } }
  const [selectedText, setSelectedText] = useState('');
  const [selectionRange, setSelectionRange] = useState(null);
  const [selectedBehavior, setSelectedBehavior] = useState(COGNITIVE_BEHAVIORS[0]);
  const [selectedScore, setSelectedScore] = useState(1);
  const [activeSpanId, setActiveSpanId] = useState(null);
  const [sampleData, setSampleData] = useState(SAMPLE_DATA);
  const [isLoading, setIsLoading] = useState(false);
  const [uploadError, setUploadError] = useState(null);

  const textRef = useRef(null);
  const fileInputRef = useRef(null);
  const annotationsInputRef = useRef(null);

  const currentTrace = sampleData[currentIndex];

  useEffect(() => {
    setSelectedText('');
    setSelectionRange(null);
    setActiveSpanId(null);
  }, [currentIndex]);

  // Normalize strings for best-effort matching (used only as fallback)
  const normalize = s => String(s || '').replace(/\u00A0/g, ' ').replace(/\r/g, '').replace(/\s+/g, ' ').trim();

  // Compute character offset (index in the full text) from a DOM Text node and its offset.
  // Walks the tree in document order until the target node is found.
  const charOffsetFromNode = (root, targetNode, nodeOffset) => {
    let offset = 0;
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null, false);
    let n;
    while ((n = walker.nextNode())) {
      if (n === targetNode) {
        return offset + nodeOffset;
      }
      offset += n.textContent.length;
    }
    return offset; // fallback
  };

  /* ---- File upload handlers ---- */
  const handleFileUpload = (event) => {
    const file = event.target.files?.[0];
    if (!file) return;
    setIsLoading(true);
    setUploadError(null);

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        const sheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(worksheet);

        const transformedData = jsonData.map((row, index) => {
          if (!row.id || !row.question || !row.reasoning) {
            throw new Error(`Row ${index + 1} is missing required columns (id, question, or reasoning)`);
          }
          // normalize NBSP and CR for display
          return {
            id: String(row.id),
            question: String(row.question),
            reasoning: String(row.reasoning).replace(/\u00A0/g, ' ').replace(/\r/g, '')
          };
        });

        if (transformedData.length === 0) throw new Error('No data found in the Excel file');

        setSampleData(transformedData);
        setCurrentIndex(0);
        setAnnotations({}); // reset annotations when loading new dataset
        setIsLoading(false);
      } catch (err) {
        setUploadError(err.message || String(err));
        setIsLoading(false);
      }
    };

    reader.onerror = () => {
      setUploadError('Failed to read the file');
      setIsLoading(false);
    };

    reader.readAsArrayBuffer(file);
  };

  const handleAnnotationsUpload = (event) => {
    const file = event.target.files?.[0];
    if (!file) return;
    setIsLoading(true);
    setUploadError(null);

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const jsonData = JSON.parse(e.target.result);
        const converted = {};

        for (const [traceId, data] of Object.entries(jsonData)) {
          if (!data.spans || !Array.isArray(data.spans)) {
            throw new Error(`Invalid format for trace ${traceId}: missing or invalid 'spans' array`);
          }
          const trace = sampleData.find(t => t.id === traceId);
          const reasoning = trace ? trace.reasoning : '';

          converted[traceId] = { spans: data.spans.map((span, idx) => {
            // support array format [text, behavior, score]
            if (Array.isArray(span)) {
              const text = String(span[0]);
              const behavior = String(span[1]);
              const score = Number(span[2]);
              let start;
              if (reasoning) start = normalize(reasoning).indexOf(normalize(text));
              return {
                id: Date.now() + idx,
                text,
                behavior,
                score,
                start: start >= 0 ? start : undefined,
                end: start >= 0 ? start + text.length : undefined
              };
            } else if (span.text && span.behavior && span.score !== undefined) {
              const s = { ...span };
              if (s.start === undefined || s.end === undefined) {
                let start = -1;
                if (reasoning) start = normalize(reasoning).indexOf(normalize(s.text));
                s.start = start >= 0 ? start : undefined;
                s.end = start >= 0 ? start + s.text.length : undefined;
              }
              s.id = s.id || Date.now() + idx;
              return s;
            } else {
              throw new Error(`Invalid span format in trace ${traceId}`);
            }
          })};
        }

        setAnnotations(converted);
        setIsLoading(false);
        alert(`Loaded annotations for ${Object.keys(converted).length} trace(s)`);
      } catch (err) {
        setUploadError(`Failed to parse annotations file: ${err.message || String(err)}`);
        setIsLoading(false);
      }
    };

    reader.onerror = () => {
      setUploadError('Failed to read the annotations file');
      setIsLoading(false);
    };

    reader.readAsText(file);
  };

  /* ---- Selection & creating annotations ---- */
  const handleTextSelection = () => {
    const selection = window.getSelection();
    const text = selection.toString().trim();
    if (text && textRef.current && textRef.current.contains(selection.anchorNode)) {
      setSelectedText(text);
      const range = selection.getRangeAt(0);
      setSelectionRange({
        startContainer: range.startContainer,
        startOffset: range.startOffset,
        endContainer: range.endContainer,
        endOffset: range.endOffset
      });
    }
  };

  const handleSubmit = () => {
    if (!selectedText || !selectionRange) return;
    // compute character offsets relative to full reasoning text
    const start = charOffsetFromNode(textRef.current, selectionRange.startContainer, selectionRange.startOffset);
    const end = charOffsetFromNode(textRef.current, selectionRange.endContainer, selectionRange.endOffset);

    const newAnnotations = { ...annotations };
    if (!newAnnotations[currentTrace.id]) newAnnotations[currentTrace.id] = { spans: [] };

    const spanData = {
      id: Date.now(),
      text: selectedText,
      behavior: selectedBehavior,
      score: selectedScore,
      start: Math.max(0, Math.min((currentTrace.reasoning || '').length, start)),
      end: Math.max(0, Math.min((currentTrace.reasoning || '').length, end))
    };

    newAnnotations[currentTrace.id].spans.push(spanData);
    setAnnotations(newAnnotations);

    // clear selection UI
    setSelectedText('');
    setSelectionRange(null);
    window.getSelection().removeAllRanges();
  };

  const handleDelete = (spanId) => {
    const newAnnotations = { ...annotations };
    if (newAnnotations[currentTrace.id]) {
      newAnnotations[currentTrace.id].spans = newAnnotations[currentTrace.id].spans.filter(s => s.id !== spanId);
    }
    setAnnotations(newAnnotations);
    if (activeSpanId === spanId) setActiveSpanId(null);
  };

  const downloadAnnotations = () => {
    const exportData = {};
    Object.keys(annotations).forEach(traceId => {
      exportData[traceId] = { spans: annotations[traceId].spans.map(span => ({
        id: span.id, text: span.text, behavior: span.behavior, score: span.score, start: span.start, end: span.end
      }))};
    });
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'annotations.json';
    a.click();
    URL.revokeObjectURL(url);
  };

  /* ---- Build character-id mapping and segments ---- */
  const getHighlightedTextSegments = () => {
    const currentSpans = annotations[currentTrace.id]?.spans || [];
    const originalText = currentTrace.reasoning || '';
    const textLength = originalText.length;

    // create array of arrays for annotation ids per character
    const charIds = Array.from({ length: textLength }, () => []);

    // populate charIds using explicit start/end when available
    currentSpans.forEach(span => {
      if (span.start !== undefined && span.end !== undefined) {
        const s = Math.max(0, Math.min(textLength, Math.floor(span.start)));
        const e = Math.max(0, Math.min(textLength, Math.ceil(span.end)));
        for (let i = s; i < e; i++) charIds[i].push(span.id);
      } else {
        // fallback: best-effort find by normalized text (writes back start/end)
        const idx = normalize(originalText).indexOf(normalize(span.text));
        if (idx >= 0) {
          for (let i = idx; i < Math.min(textLength, idx + span.text.length); i++) charIds[i].push(span.id);
          span.start = idx;
          span.end = idx + span.text.length;
        }
      }
    });

    // compress into segments where the id-list is the same
    const segments = [];
    let i = 0;
    while (i < textLength) {
      const ids = charIds[i];
      let j = i + 1;
      while (j < textLength) {
        const a = charIds[j];
        if (a.length !== ids.length) break;
        // compare arrays shallowly
        let same = true;
        for (let k = 0; k < a.length; k++) {
          if (a[k] !== ids[k]) { same = false; break; }
        }
        if (!same) break;
        j++;
      }
      const segText = originalText.slice(i, j);
      segments.push({
        text: segText,
        ids: ids.slice(),
        isHighlight: ids.length > 0,
        isActive: activeSpanId ? ids.includes(activeSpanId) : false
      });
      i = j;
    }

    // if text is empty, return an empty segment
    if (segments.length === 0) return [{ text: originalText, ids: [], isHighlight: false, isActive: false }];
    return segments;
  };

  const segments = getHighlightedTextSegments();

  /* Scroll helper: scroll the first element that contains the annotation id */
  const scrollToSpan = (spanId) => {
    requestAnimationFrame(() => {
      const el = textRef.current?.querySelector(`[data-annotation-ids*="${spanId}"]`);
      if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
    });
  };

  /* Render */
  return (
    <div className="min-h-screen bg-gray-50 p-8">
      <div className="max-w-5xl mx-auto">
        <div className="bg-white rounded-lg shadow-lg p-6">
          <div className="flex justify-between items-center mb-6">
            <h1 className="text-2xl font-bold text-gray-800">LLM Reasoning Trace Annotator</h1>
            <div className="flex gap-3">
              <input type="file" ref={fileInputRef} onChange={handleFileUpload} accept=".xlsx,.xls" className="hidden" />
              <input type="file" ref={annotationsInputRef} onChange={handleAnnotationsUpload} accept=".json" className="hidden" />
              <button onClick={() => fileInputRef.current?.click()} disabled={isLoading} className="flex items-center gap-2 bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition">
                <Upload size={20} /> {isLoading ? 'Loading...' : 'Upload XLSX'}
              </button>
              <button onClick={() => annotationsInputRef.current?.click()} disabled={isLoading} className="flex items-center gap-2 bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition">
                <Upload size={20} /> {isLoading ? 'Loading...' : 'Load Annotations'}
              </button>
              <button onClick={downloadAnnotations} className="flex items-center gap-2 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition">
                <Download size={20} /> Download Annotations
              </button>
            </div>
          </div>

          {uploadError && (
            <div className="mb-4 p-4 bg-red-50 border border-red-200 rounded-lg">
              <p className="text-red-800 text-sm"><strong>Error:</strong> {uploadError}</p>
            </div>
          )}

          <div className="mb-6 p-4 bg-gray-100 rounded-lg">
            <div className="flex items-center justify-between mb-4">
              <button onClick={() => setCurrentIndex(Math.max(0, currentIndex - 1))} disabled={currentIndex === 0} className="p-2 rounded-lg bg-white hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed transition"><ChevronLeft size={24} /></button>
              <span className="text-lg font-semibold">Question {currentIndex + 1} of {sampleData.length}</span>
              <button onClick={() => setCurrentIndex(Math.min(sampleData.length - 1, currentIndex + 1))} disabled={currentIndex === sampleData.length - 1} className="p-2 rounded-lg bg-white hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed transition"><ChevronRight size={24} /></button>
            </div>
            <div className="text-sm text-gray-600 mb-2">ID: {currentTrace.id}</div>
            <div className="font-semibold text-gray-800">{currentTrace.question}</div>
          </div>

          <div className="mb-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg relative">
            <h3 className="font-semibold mb-2 text-gray-700">Reasoning Trace:</h3>
            <div ref={textRef} onMouseUp={handleTextSelection} className="text-gray-800 leading-relaxed select-text cursor-text relative">
              {segments.map((segment, idx) => {
                if (!segment.isHighlight) return <span key={idx}>{segment.text}</span>;

                // choose class: active -> behavior color (from active span), else default yellow
                const cls = segment.isActive
                  ? (() => {
                      const spans = annotations[currentTrace.id]?.spans || [];
                      const activeSpan = spans.find(s => s.id === activeSpanId);
                      const behaviorClass = activeSpan ? (BEHAVIOR_COLOR[activeSpan.behavior] || BEHAVIOR_COLOR.default) : BEHAVIOR_COLOR.default;
                      return `annotation-span ${behaviorClass} text-black`;
                    })()
                  : 'annotation-span bg-yellow-300';

                return (
                  <span key={idx} data-annotation-ids={segment.ids.join(',')} className={cls}>
                    {segment.text}
                  </span>
                );
              })}
            </div>
          </div>

          <div className="border-t pt-6">
            <h3 className="font-semibold mb-4 text-gray-700">Annotate Selection</h3>

            {selectedText && (
              <div className="mb-4 p-3 bg-green-50 border border-green-200 rounded-lg">
                <div className="text-sm text-gray-600 mb-1">Selected text:</div>
                <div className="font-medium text-gray-800">"{selectedText}"</div>
              </div>
            )}

            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">Cognitive Behavior:</label>
                <select value={selectedBehavior} onChange={(e) => setSelectedBehavior(e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                  {COGNITIVE_BEHAVIORS.map(b => <option key={b} value={b}>{b}</option>)}
                </select>
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">Score:</label>
                <div className="flex gap-4">
                  <label className="flex items-center"><input type="radio" name="score" value="1" checked={selectedScore === 1} onChange={() => setSelectedScore(1)} className="mr-2" />1</label>
                  <label className="flex items-center"><input type="radio" name="score" value="2" checked={selectedScore === 2} onChange={() => setSelectedScore(2)} className="mr-2" />2</label>
                </div>
              </div>

              <div className="flex items-end">
                <button onClick={handleSubmit} disabled={!selectedText} className="w-full bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition font-medium">Submit Annotation</button>
              </div>
            </div>

            <div className="mt-6">
              <h4 className="font-semibold text-gray-700 mb-2">Current Annotations ({annotations[currentTrace.id]?.spans?.length || 0})</h4>

              {annotations[currentTrace.id]?.spans?.length > 0 ? (
                <div className="space-y-2">
                  {annotations[currentTrace.id].spans.map(span => (
                    <div key={span.id} className={`p-3 rounded-lg border cursor-pointer transition ${activeSpanId === span.id ? 'bg-orange-100 border-orange-400' : 'bg-gray-50 border-gray-200 hover:bg-gray-100'}`} onClick={() => {
                      if (activeSpanId === span.id) {
                        setActiveSpanId(null);
                      } else {
                        setActiveSpanId(span.id);
                        scrollToSpan(span.id);
                      }
                    }}>
                      <div className="flex justify-between items-start">
                        <div className="flex-1">
                          <div className="text-sm"><strong>Text:</strong> "{span.text}"</div>
                          <div className="text-sm"><strong>Behavior:</strong> {span.behavior}</div>
                          <div className="text-sm"><strong>Score:</strong> {span.score}</div>
                        </div>
                        <button onClick={(e) => { e.stopPropagation(); handleDelete(span.id); }} className="ml-3 p-2 text-red-600 hover:bg-red-100 rounded transition" title="Delete annotation"><Trash2 size={18} /></button>
                      </div>
                    </div>
                  ))}
                </div>
              ) : (
                <div className="text-gray-500 italic">No annotations yet for this trace.</div>
              )}
            </div>
          </div>

        </div>
      </div>
    </div>
  );
}

/* Mount */
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<LLMTraceAnnotator />);
</script>
</body>
</html>
